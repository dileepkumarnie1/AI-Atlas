name: Feature/Functionality testing

on:
  workflow_dispatch:
    inputs:
      base_url:
        description: "Base URL to test against (required unless set by environment)"
        required: false
        type: string
      feature:
        description: "Feature to test (choose 'All' for full regression)."
        required: true
        default: "All"
        type: choice
        options:
          - All
          - Mobile Nav
          - Background Fix
          - Accessibility
          - Admin Health Endpoint
          - Admin Dispatch Endpoint
          - Legacy Cleanup
          - Search
          - Category Filter
          - Domain Navigation
          - Tool Details
          - Theme Toggle
          - Auth
          - Favorites
          - Admin Moderation

permissions:
  contents: read      # allow checkout and artifact upload
  issues: write       # needed for creating/updating failure issue
  pull-requests: write # needed for sticky PR comments

jobs:
  select-tests:
    name: Select tests (dropdown)
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.build.outputs.matrix }}
    steps:
      - name: Build test matrix from dropdown
        id: build
        run: |
          set -euo pipefail
          sel='${{ inputs.feature }}'
          if [ "$sel" = "All" ]; then
            json='{"include":[{"feature":"ALL"}]}'
          else
            json=$(printf '{"include":[{"feature":"%s"}]}' "$sel")
          fi
          {
            echo "matrix<<JSON"
            echo "$json"
            echo JSON
          } >> "$GITHUB_OUTPUT"

  ui-tests:
    name: Playwright UI tests (tests only)
    runs-on: ubuntu-latest
    needs: select-tests
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.select-tests.outputs.matrix) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure TEST_BASE_URL
        run: |
          URL='${{ inputs.base_url }}'
          if [ -z "$URL" ]; then
            # Fallback to environment variable if runner/env provides it
            URL="${TEST_BASE_URL:-}"
          fi
          if [ -z "$URL" ]; then
            # Auto-derive GitHub Pages URL for this repo
            OWNER="$GITHUB_REPOSITORY_OWNER"
            REPO="${GITHUB_REPOSITORY#*/}"
            if echo "$REPO" | grep -qiE '\\.github\\.io$'; then
              # User/Org site repo: owner.github.io
              URL="https://$REPO"
            else
              # Project site repo: owner.github.io/repo
              # Note: This assumes default Pages domain (no custom domain)
              URL="https://$OWNER.github.io/$REPO"
            fi
          fi
          if [ -z "$URL" ]; then
            echo "TEST_BASE_URL was not provided and could not be derived. Pass 'base_url' input or set TEST_BASE_URL in env." >&2
            exit 1
          fi
          echo "Using TEST_BASE_URL=$URL"
          echo "TEST_BASE_URL=$URL" >> "$GITHUB_ENV"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r tests/requirements.txt

      - name: Install Playwright browsers
        run: |
          python -m playwright install --with-deps

      - name: Prepare optional auth envs
        run: |
          if [ -n "${{ secrets.TEST_USER_EMAIL }}" ]; then
            echo "TEST_USER_EMAIL=${{ secrets.TEST_USER_EMAIL }}" >> "$GITHUB_ENV"
          elif [ -n "${{ vars.TEST_USER_EMAIL }}" ]; then
            echo "TEST_USER_EMAIL=${{ vars.TEST_USER_EMAIL }}" >> "$GITHUB_ENV"
          else
            echo "TEST_USER_EMAIL=" >> "$GITHUB_ENV"
          fi
          if [ -n "${{ secrets.TEST_USER_PASSWORD }}" ]; then
            echo "TEST_USER_PASSWORD=${{ secrets.TEST_USER_PASSWORD }}" >> "$GITHUB_ENV"
          elif [ -n "${{ vars.TEST_USER_PASSWORD }}" ]; then
            echo "TEST_USER_PASSWORD=${{ vars.TEST_USER_PASSWORD }}" >> "$GITHUB_ENV"
          else
            echo "TEST_USER_PASSWORD=" >> "$GITHUB_ENV"
          fi


      - name: Run UI tests
        env:
          TEST_BASE_URL: ${{ env.TEST_BASE_URL }}
          TEST_USER_EMAIL: ${{ env.TEST_USER_EMAIL }}
          TEST_USER_PASSWORD: ${{ env.TEST_USER_PASSWORD }}
        run: |
          FEAT='${{ matrix.feature }}'
          SLUG=$(echo "$FEAT" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd 'a-z0-9-')
          if [ "$FEAT" = "ALL" ]; then
            echo "Running full regression"
            python tests/run_ui_tests.py --out-dir "tests/output/all"
          else
            echo "Running feature: $FEAT"
            python tests/run_ui_tests.py --features "$FEAT" --out-dir "tests/output/$SLUG"
          fi


      - name: Upload UI test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ui-test-artifacts-${{ matrix.feature }}
          path: |
            tests/**/*.csv
            tests/**/*.xlsx
            tests/**/screenshots/**
          if-no-files-found: warn

  summarize-failures:
    name: Summarize & Report Failures
    runs-on: ubuntu-latest
    needs: ui-tests
    if: always()
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Consolidate results directory
        run: |
          set -euo pipefail
          mkdir -p tests/output
          # Move any results.csv files into tests/output preserving structure
          shopt -s globstar || true
          find artifacts -type f -name results.csv -exec bash -c 'd="$1"; base=${d#artifacts/}; dest=tests/output/${base%/results.csv}; mkdir -p "$(dirname "tests/output/$base")"; cp "$d" "tests/output/$base"' _ {} \;

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install minimal deps for parsing
        run: |
          python -m pip install --upgrade pip

      - name: Parse failures
        id: parse
        run: |
          python scripts/parse-test-failures.py || echo "parse_exit=$?" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Determine failure status
        id: status
        run: |
          if [ -f tests/output/failures.json ]; then
            total=$(jq '.total_failures' tests/output/failures.json || echo 0)
          else
            total=0
          fi
          echo "total_failures=$total" >> $GITHUB_OUTPUT
          if [ "$total" -gt 0 ]; then
            echo "had_failures=true" >> $GITHUB_OUTPUT
          else
            echo "had_failures=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload failure summary artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ui-failure-summary
          path: |
            tests/output/failures.json
            tests/output/failures.md
            tests/output/summary-stats.json
          if-no-files-found: ignore

      - name: Zip screenshots (if any)
        if: always()
        run: |
          set -euo pipefail
            
          if compgen -G "artifacts/**/screenshots/*.png" > /dev/null; then
            mkdir -p tests/output
            zip -r tests/output/screenshots.zip artifacts/**/screenshots/*.png || true
          else
            echo "No screenshots found to zip"
          fi

      - name: Upload screenshots zip
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ui-screenshots-zip
          path: tests/output/screenshots.zip
          if-no-files-found: ignore

      - name: Create or update failure issue
        if: steps.status.outputs.had_failures == 'true'
        uses: peter-evans/create-issue-from-file@v5
        with:
          title: "UI Test Failures Detected"
          content-filepath: tests/output/failures.md
          labels: tests, ui, automated
          assignees: ${{ github.actor }}
          # The action auto-deduplicates if 'content-filepath' unchanged; no custom inputs for update/ search now

      - name: Attach screenshots zip to issue (if failures)
        if: steps.status.outputs.had_failures == 'true' && hashFiles('tests/output/screenshots.zip') != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          issue_number=$(gh issue list --state open --search "UI Test Failures Detected in:title" --json number --jq '.[0].number')
          if [ -n "$issue_number" ]; then
            gh issue comment "$issue_number" --body "Attaching screenshots zip." || true
            gh release view ci-test-screenshots >/dev/null 2>&1 && exists=1 || exists=0
            # Use release asset as a durable attachment (workaround for large zips)
            if [ $exists -eq 0 ]; then
              gh release create ci-test-screenshots tests/output/screenshots.zip -t "CI Test Screenshots" -n "Screenshots from failed UI tests" || true
            else
              gh release upload ci-test-screenshots tests/output/screenshots.zip --clobber || true
            fi
          fi

      - name: Post failure comment (summary)
        if: steps.status.outputs.had_failures == 'true'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
            recreate: true
            path: tests/output/failures.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


      - name: Set workflow conclusion
        if: steps.status.outputs.had_failures == 'true'
        run: |
          echo "One or more UI tests failed." >&2
          exit 1

      - name: Close existing failure issue if now passing
        if: steps.status.outputs.had_failures == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          issue_number=$(gh issue list --state open --search "UI Test Failures Detected in:title" --json number --jq '.[0].number') || true
          if [ -n "$issue_number" ]; then
            gh issue comment "$issue_number" --body "All tests now passing. Closing issue automatically." || true
            gh issue close "$issue_number" || true
          else
            echo "No open failure issue to close." 
